package net.saga.console.emulator.sms.sms4j.test;

import net.saga.console.emulator.sms.sms4j.test.util.ByteArrayConverter;
import net.saga.console.emulator.sms.sms4j.z80.Z80;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.converter.ConvertWith;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class SubtractTest {
    @ParameterizedTest
    @CsvSource({"'0x3E, 0x44, 0x06, 0x11, 0x90'",//LD a nn, LD b nn, SUB A B
                "'0x3E, 0x44, 0x06, 0x0F, 0x90'",
                "'0x3E, 0x44, 0x06, 0xFF, 0x90'",
                "'0x3E, 0x44, 0x06, 0x01, 0x90'",
                "'0x3E, 0xF4, 0x06, 0x11, 0x90'",
                "'0x3E, 0xF4, 0x06, 0x0F, 0x90'",
                "'0x3E, 0xF4, 0x06, 0xFF, 0x90'",
                "'0x3E, 0xF4, 0x06, 0x01, 0x90'",
            "'0x3E, 0x44, 0x0E, 0x11, 0x91'",//LD a nn, LD c nn, SUB A c
            "'0x3E, 0x44, 0x0E, 0x0F, 0x91'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0x91'",
            "'0x3E, 0x44, 0x0E, 0x01, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0x91'",
            "'0x3E, 0x44, 0x16, 0x11, 0x92'",//LD a nn, LD d nn, SUB A d
            "'0x3E, 0x44, 0x16, 0x0F, 0x92'",
            "'0x3E, 0x44, 0x16, 0xFF, 0x92'",
            "'0x3E, 0x44, 0x16, 0x01, 0x92'",
            "'0x3E, 0xF4, 0x16, 0x11, 0x92'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0x92'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0x92'",
            "'0x3E, 0xF4, 0x16, 0x01, 0x92'",
            "'0x3E, 0x44, 0x1E, 0x11, 0x93'",//LD a nn, LD e nn, SUB A e
            "'0x3E, 0x44, 0x1E, 0x0F, 0x93'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0x93'",
            "'0x3E, 0x44, 0x1E, 0x01, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0x93'",
            "'0x3E, 0x44, 0x26, 0x11, 0x94'",//LD a nn, LD h nn, SUB A h
            "'0x3E, 0x44, 0x26, 0x0F, 0x94'",
            "'0x3E, 0x44, 0x26, 0xFF, 0x94'",
            "'0x3E, 0x44, 0x26, 0x01, 0x94'",
            "'0x3E, 0xF4, 0x26, 0x11, 0x94'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0x94'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0x94'",
            "'0x3E, 0xF4, 0x26, 0x01, 0x94'",
            "'0x3E, 0x44, 0x2E, 0x11, 0x95'",//LD a nn, LD l nn, SUB A l
            "'0x3E, 0x44, 0x2E, 0x0F, 0x95'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0x95'",
            "'0x3E, 0x44, 0x2E, 0x01, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0x95'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0x97'",//LD a nn, LD a nn, SUB A A
    })
    public void testSubtract(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        int regValue = memory[3] & 0xFF;
        int aValue = memory[1] & 0xFF;
        int trueValue = aValue - regValue;

        byte maskedValue = (byte) (trueValue & 0xFF);
        assertEquals(maskedValue, z80.getA());
        assertEquals(maskedValue < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals((((0x0F & aValue) - (0x0F & regValue)) < 0x0), z80.getFlagH(), "Flag H contained the wrong value");
        boolean overflow = trueValue > aValue;
        assertEquals(overflow, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(trueValue > 0xFF, z80.getFlagC(), "Flag C contained the wrong value");

    }

    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0x11'", //LD a n, LD HL nn, SUB_A (HL)
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0x0F'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0xFF'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0x01'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0x11'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0x0F'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0xFF'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0x01'",
    })
    public void testSubAtHL(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(24);

        int regValue = memory[6] & 0xFF;
        int aValue = memory[1] & 0xFF;
        int trueValue = aValue - regValue;

        byte maskedValue = (byte) (trueValue & 0xFF);
        assertEquals(maskedValue, z80.getA());
        assertEquals(maskedValue < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals((((0x0F & aValue) - (0x0F & regValue)) < 0x0), z80.getFlagH(), "Flag H contained the wrong value");
        boolean overflow = trueValue > aValue;
        assertEquals(overflow, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(trueValue > 0xFF, z80.getFlagC(), "Flag C contained the wrong value");
    }

}
