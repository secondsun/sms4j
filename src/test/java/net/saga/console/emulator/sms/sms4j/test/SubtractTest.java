package net.saga.console.emulator.sms.sms4j.test;

import net.saga.console.emulator.sms.sms4j.test.util.ByteArrayConverter;
import net.saga.console.emulator.sms.sms4j.z80.Z80;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.converter.ConvertWith;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class SubtractTest {
    @ParameterizedTest
    @CsvSource({"'0x3E, 0x44, 0x06, 0x11, 0x90'",//LD a nn, LD b nn, SUB A B
                "'0x3E, 0x44, 0x06, 0x0F, 0x90'",
                "'0x3E, 0x44, 0x06, 0xFF, 0x90'",
                "'0x3E, 0x44, 0x06, 0x01, 0x90'",
                "'0x3E, 0xF4, 0x06, 0x11, 0x90'",
                "'0x3E, 0xF4, 0x06, 0x0F, 0x90'",
                "'0x3E, 0xF4, 0x06, 0xFF, 0x90'",
                "'0x3E, 0xF4, 0x06, 0x01, 0x90'",
            "'0x3E, 0x44, 0x0E, 0x11, 0x91'",//LD a nn, LD c nn, SUB A c
            "'0x3E, 0x44, 0x0E, 0x0F, 0x91'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0x91'",
            "'0x3E, 0x44, 0x0E, 0x01, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0x91'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0x91'",
            "'0x3E, 0x44, 0x16, 0x11, 0x92'",//LD a nn, LD d nn, SUB A d
            "'0x3E, 0x44, 0x16, 0x0F, 0x92'",
            "'0x3E, 0x44, 0x16, 0xFF, 0x92'",
            "'0x3E, 0x44, 0x16, 0x01, 0x92'",
            "'0x3E, 0xF4, 0x16, 0x11, 0x92'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0x92'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0x92'",
            "'0x3E, 0xF4, 0x16, 0x01, 0x92'",
            "'0x3E, 0x44, 0x1E, 0x11, 0x93'",//LD a nn, LD e nn, SUB A e
            "'0x3E, 0x44, 0x1E, 0x0F, 0x93'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0x93'",
            "'0x3E, 0x44, 0x1E, 0x01, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0x93'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0x93'",
            "'0x3E, 0x44, 0x26, 0x11, 0x94'",//LD a nn, LD h nn, SUB A h
            "'0x3E, 0x44, 0x26, 0x0F, 0x94'",
            "'0x3E, 0x44, 0x26, 0xFF, 0x94'",
            "'0x3E, 0x44, 0x26, 0x01, 0x94'",
            "'0x3E, 0xF4, 0x26, 0x11, 0x94'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0x94'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0x94'",
            "'0x3E, 0xF4, 0x26, 0x01, 0x94'",
            "'0x3E, 0x44, 0x2E, 0x11, 0x95'",//LD a nn, LD l nn, SUB A l
            "'0x3E, 0x44, 0x2E, 0x0F, 0x95'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0x95'",
            "'0x3E, 0x44, 0x2E, 0x01, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0x95'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0x95'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0x97'",//LD a nn, LD a nn, SUB A A
    })
    public void testSubtract(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        int regValue = memory[3] & 0xFF;
        int aValue = memory[1] & 0xFF;
        int trueValue = aValue - regValue;

        byte maskedValue = (byte) (trueValue & 0xFF);
        System.out.println(Integer.toString(z80.getRegisterF().getValue(),2));
        assertEquals(maskedValue, z80.getA());
        assertEquals(maskedValue < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals((((0x0F & aValue) - (0x0F & regValue)) < 0x0), z80.getFlagH(), "Flag H contained the wrong value");
        boolean overflow = trueValue > aValue;
        assertEquals(overflow, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(regValue > aValue, z80.getFlagC(), "Flag C contained the wrong value");

    }

    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0x11'", //LD a n, LD HL nn, SUB_A (HL)
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0x0F'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0xFF'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0x96, 0x01'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0x11'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0x0F'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0xFF'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0x96, 0x01'",
    })
    public void testSubAtHL(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(24);

        int regValue = memory[6] & 0xFF;
        int aValue = memory[1] & 0xFF;
        int trueValue = aValue - regValue;

        byte maskedValue = (byte) (trueValue & 0xFF);
        assertEquals(maskedValue, z80.getA());
        assertEquals(maskedValue < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals((((0x0F & aValue) - (0x0F & regValue)) < 0x0), z80.getFlagH(), "Flag H contained the wrong value");
        boolean overflow = trueValue > aValue;
        assertEquals(overflow, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(regValue > aValue, z80.getFlagC(), "Flag C contained the wrong value");
    }

    @CsvSource({"'0x3E, 0x44, 0x06, 0x11, 0x98, 0'",//LD a nn, LD b nn, SBC A B
            "'0x3E, 0x44, 0x06, 0x0F, 0x98, 0'",
            "'0x3E, 0x44, 0x06, 0xFF, 0x98, 0'",
            "'0x3E, 0x44, 0x06, 0x01, 0x98, 0'",
            "'0x3E, 0xF4, 0x06, 0x11, 0x98, 0'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0x98, 0'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0x98, 0'",
            "'0x3E, 0xF4, 0x06, 0x01, 0x98, 0'",
            "'0x3E, 0x44, 0x0E, 0x11, 0x99, 0'",//LD a nn, LD c nn, SBC A c
            "'0x3E, 0x44, 0x0E, 0x0F, 0x99, 0'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0x99, 0'",
            "'0x3E, 0x44, 0x0E, 0x01, 0x99, 0'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0x99, 0'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0x99, 0'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0x99, 0'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0x99, 0'",
            "'0x3E, 0x44, 0x16, 0x11, 0x9a, 0'",//LD a nn, LD d nn, SBC A d
            "'0x3E, 0x44, 0x16, 0x0F, 0x9a, 0'",
            "'0x3E, 0x44, 0x16, 0xFF, 0x9a, 0'",
            "'0x3E, 0x44, 0x16, 0x01, 0x9a, 0'",
            "'0x3E, 0xF4, 0x16, 0x11, 0x9a, 0'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0x9a, 0'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0x9a, 0'",
            "'0x3E, 0xF4, 0x16, 0x01, 0x9a, 0'",
            "'0x3E, 0x44, 0x1E, 0x11, 0x9b, 0'",//LD a nn, LD e nn, SBC A e
            "'0x3E, 0x44, 0x1E, 0x0F, 0x9b, 0'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0x9b, 0'",
            "'0x3E, 0x44, 0x1E, 0x01, 0x9b, 0'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0x9b, 0'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0x9b, 0'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0x9b, 0'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0x9b, 0'",
            "'0x3E, 0x44, 0x26, 0x11, 0x9c, 0'",//LD a nn, LD h nn, SBC A h
            "'0x3E, 0x44, 0x26, 0x0F, 0x9c, 0'",
            "'0x3E, 0x44, 0x26, 0xFF, 0x9c, 0'",
            "'0x3E, 0x44, 0x26, 0x01, 0x9c, 0'",
            "'0x3E, 0xF4, 0x26, 0x11, 0x9c, 0'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0x9c, 0'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0x9c, 0'",
            "'0x3E, 0xF4, 0x26, 0x01, 0x9c, 0'",
            "'0x3E, 0x44, 0x2E, 0x11, 0x9d, 0'",//LD a nn, LD l nn, SBC A l
            "'0x3E, 0x44, 0x2E, 0x0F, 0x9d, 0'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0x9d, 0'",
            "'0x3E, 0x44, 0x2E, 0x01, 0x9d, 0'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0x9d, 0'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0x9d, 0'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0x9d, 0'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0x9d, 0'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0x9f, 0'",//LD a nn, LD a nn, SBC A A
            "'0x3E, 0x44, 0x06, 0x11, 0x98, 01'",//LD a nn, LD b nn, SBC A B
            "'0x3E, 0x44, 0x06, 0x0F, 0x98, 01'",
            "'0x3E, 0x44, 0x06, 0xFF, 0x98, 01'",
            "'0x3E, 0x44, 0x06, 0x01, 0x98, 01'",
            "'0x3E, 0xF4, 0x06, 0x11, 0x98, 01'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0x98, 01'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0x98, 01'",
            "'0x3E, 0xF4, 0x06, 0x01, 0x98, 01'",
            "'0x3E, 0x44, 0x0E, 0x11, 0x99, 01'",//LD a nn, LD c nn, SBC A c
            "'0x3E, 0x44, 0x0E, 0x0F, 0x99, 01'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0x99, 01'",
            "'0x3E, 0x44, 0x0E, 0x01, 0x99, 01'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0x99, 01'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0x99, 01'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0x99, 01'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0x99, 01'",
            "'0x3E, 0x44, 0x16, 0x11, 0x9a, 01'",//LD a nn, LD d nn, SBC A d
            "'0x3E, 0x44, 0x16, 0x0F, 0x9a, 01'",
            "'0x3E, 0x44, 0x16, 0xFF, 0x9a, 01'",
            "'0x3E, 0x44, 0x16, 0x01, 0x9a, 01'",
            "'0x3E, 0xF4, 0x16, 0x11, 0x9a, 01'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0x9a, 01'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0x9a, 01'",
            "'0x3E, 0xF4, 0x16, 0x01, 0x9a, 01'",
            "'0x3E, 0x44, 0x1E, 0x11, 0x9b, 01'",//LD a nn, LD e nn, SBC A e
            "'0x3E, 0x44, 0x1E, 0x0F, 0x9b, 01'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0x9b, 01'",
            "'0x3E, 0x44, 0x1E, 0x01, 0x9b, 01'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0x9b, 01'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0x9b, 01'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0x9b, 01'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0x9b, 01'",
            "'0x3E, 0x44, 0x26, 0x11, 0x9c, 01'",//LD a nn, LD h nn, SBC A h
            "'0x3E, 0x44, 0x26, 0x0F, 0x9c, 01'",
            "'0x3E, 0x44, 0x26, 0xFF, 0x9c, 01'",
            "'0x3E, 0x44, 0x26, 0x01, 0x9c, 01'",
            "'0x3E, 0xF4, 0x26, 0x11, 0x9c, 01'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0x9c, 01'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0x9c, 01'",
            "'0x3E, 0xF4, 0x26, 0x01, 0x9c, 01'",
            "'0x3E, 0x44, 0x2E, 0x11, 0x9d, 01'",//LD a nn, LD l nn, SBC A l
            "'0x3E, 0x44, 0x2E, 0x0F, 0x9d, 01'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0x9d, 01'",
            "'0x3E, 0x44, 0x2E, 0x01, 0x9d, 01'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0x9d, 01'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0x9d, 01'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0x9d, 01'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0x9d, 01'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0x9f, 01'",//LD a nn, LD a nn, SBC A A
    })
    public void testSubtractWithCarry(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);
        z80.setCarry(memory[5] > 0);
        int regValue = memory[3] & 0xFF;
        int aValue = memory[1] & 0xFF;
        int trueValue = aValue - regValue;
        if (memory[5] > 0) trueValue--;

        byte maskedValue = (byte) (trueValue & 0xFF);
        assertEquals(maskedValue, z80.getA());
        assertEquals(maskedValue < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals((((0x0F & aValue) - (0x0F & regValue)) < 0x0), z80.getFlagH(), "Flag H contained the wrong value");
        boolean overflow = trueValue > aValue;
        assertEquals(overflow, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(trueValue > 0xFF, z80.getFlagC(), "Flag C contained the wrong value");

    }

}
