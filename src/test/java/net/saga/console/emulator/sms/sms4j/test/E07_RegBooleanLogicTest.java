package net.saga.console.emulator.sms.sms4j.test;

import net.saga.console.emulator.sms.sms4j.test.util.ByteArrayConverter;
import net.saga.console.emulator.sms.sms4j.z80.Z80;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.converter.ConvertWith;
import org.junit.jupiter.params.provider.CsvSource;

import static net.saga.console.emulator.sms.sms4j.util.Utils.countBits;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class E07_RegBooleanLogicTest {


    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x06, 0x11, 0xA0'",//LD A n, LD B n, AND B
            "'0x3E, 0x44, 0x06, 0x0F, 0xA0'",
            "'0x3E, 0x44, 0x06, 0xFF, 0xA0'",
            "'0x3E, 0x44, 0x06, 0x01, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0x11, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0x01, 0xA0'",
            "'0x3E, 0x44, 0x0E, 0x11, 0xA1'",//LD A n, LD C n, AND C
            "'0x3E, 0x44, 0x0E, 0x0F, 0xA1'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0xA1'",
            "'0x3E, 0x44, 0x0E, 0x01, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0xA1'",
            "'0x3E, 0x44, 0x16, 0x11, 0xA2'",//LD A n, LD D n, AND D
            "'0x3E, 0x44, 0x16, 0x0F, 0xA2'",
            "'0x3E, 0x44, 0x16, 0xFF, 0xA2'",
            "'0x3E, 0x44, 0x16, 0x01, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0x11, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0x01, 0xA2'",
            "'0x3E, 0x44, 0x1E, 0x11, 0xA3'",//LD A n, LD E n, AND E
            "'0x3E, 0x44, 0x1E, 0x0F, 0xA3'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0xA3'",
            "'0x3E, 0x44, 0x1E, 0x01, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0xA3'",
            "'0x3E, 0x44, 0x26, 0x11, 0xA4'",//LD A n, LD H n, AND H
            "'0x3E, 0x44, 0x26, 0x0F, 0xA4'",
            "'0x3E, 0x44, 0x26, 0xFF, 0xA4'",
            "'0x3E, 0x44, 0x26, 0x01, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0x11, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0x01, 0xA4'",
            "'0x3E, 0x44, 0x2E, 0x11, 0xA5'",//LD A n, LD L n, AND L
            "'0x3E, 0x44, 0x2E, 0x0F, 0xA5'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0xA5'",
            "'0x3E, 0x44, 0x2E, 0x01, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0xA5'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0xA7'",//LD A, AND A
    })
    public void testAnd(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        byte val = memory[1];
        byte val2 = memory[3];

        byte res = (byte)(val & val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(true, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }

    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0x11'",//LD A n, LD HL n, AND (HL)
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0x0F'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0xFF'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0x01'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0x11'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0x0F'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0xFF'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0x01'"
    })
    public void testAndAtHL(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(24);

        byte val = memory[1];
        byte val2 = memory[6];

        byte res = (byte)(val & val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(true, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }




    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x06, 0x11, 0xA8'",//LD A n, LD B n, XOR B
            "'0x3E, 0x44, 0x06, 0x0F, 0xA8'",
            "'0x3E, 0x44, 0x06, 0xFF, 0xA8'",
            "'0x3E, 0x44, 0x06, 0x01, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0x11, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0x01, 0xA8'",
            "'0x3E, 0x44, 0x0E, 0x11, 0xA9'",//LD A n, LD C n, XOR C
            "'0x3E, 0x44, 0x0E, 0x0F, 0xA9'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0xA9'",
            "'0x3E, 0x44, 0x0E, 0x01, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0xA9'",
            "'0x3E, 0x44, 0x16, 0x11, 0xAA'",//LD A n, LD D n, XOR D
            "'0x3E, 0x44, 0x16, 0x0F, 0xAA'",
            "'0x3E, 0x44, 0x16, 0xFF, 0xAA'",
            "'0x3E, 0x44, 0x16, 0x01, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0x11, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0x01, 0xAA'",
            "'0x3E, 0x44, 0x1E, 0x11, 0xAB'",//LD A n, LD E n, XOR E
            "'0x3E, 0x44, 0x1E, 0x0F, 0xAB'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0xAB'",
            "'0x3E, 0x44, 0x1E, 0x01, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0xAB'",
            "'0x3E, 0x44, 0x26, 0x11, 0xAC'",//LD A n, LD H n, XOR H
            "'0x3E, 0x44, 0x26, 0x0F, 0xAC'",
            "'0x3E, 0x44, 0x26, 0xFF, 0xAC'",
            "'0x3E, 0x44, 0x26, 0x01, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0x11, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0x01, 0xAC'",
            "'0x3E, 0x44, 0x2E, 0x11, 0xAD'",//LD A n, LD L n, XOR L
            "'0x3E, 0x44, 0x2E, 0x0F, 0xAD'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0xAD'",
            "'0x3E, 0x44, 0x2E, 0x01, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0xAD'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0xAF'",//LD A, AND A
    })
    public void testXor(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        byte val = memory[1];
        byte val2 = memory[3];

        byte res = (byte)(val ^ val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(false, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }

    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0x11'",//LD A n, LD HL n, XOR (HL)
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0x0F'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0xFF'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0x01'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0x11'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0x0F'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0xFF'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0x01'"
    })
    public void testXorAtHL(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(24);

        byte val = memory[1];
        byte val2 = memory[6];

        byte res = (byte)(val ^ val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(false, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }


    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x06, 0x11, 0xB0'",//LD A n, LD B n, AND B
            "'0x3E, 0x44, 0x06, 0x0F, 0xB0'",
            "'0x3E, 0x44, 0x06, 0xFF, 0xB0'",
            "'0x3E, 0x44, 0x06, 0x01, 0xB0'",
            "'0x3E, 0xF4, 0x06, 0x11, 0xB0'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0xB0'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0xB0'",
            "'0x3E, 0xF4, 0x06, 0x01, 0xB0'",
            "'0x3E, 0x44, 0x0E, 0x11, 0xB1'",//LD A n, LD C n, AND C
            "'0x3E, 0x44, 0x0E, 0x0F, 0xB1'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0xB1'",
            "'0x3E, 0x44, 0x0E, 0x01, 0xB1'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0xB1'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0xB1'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0xB1'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0xB1'",
            "'0x3E, 0x44, 0x16, 0x11, 0xB2'",//LD A n, LD D n, AND D
            "'0x3E, 0x44, 0x16, 0x0F, 0xB2'",
            "'0x3E, 0x44, 0x16, 0xFF, 0xB2'",
            "'0x3E, 0x44, 0x16, 0x01, 0xB2'",
            "'0x3E, 0xF4, 0x16, 0x11, 0xB2'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0xB2'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0xB2'",
            "'0x3E, 0xF4, 0x16, 0x01, 0xB2'",
            "'0x3E, 0x44, 0x1E, 0x11, 0xB3'",//LD A n, LD E n, AND E
            "'0x3E, 0x44, 0x1E, 0x0F, 0xB3'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0xB3'",
            "'0x3E, 0x44, 0x1E, 0x01, 0xB3'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0xB3'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0xB3'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0xB3'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0xB3'",
            "'0x3E, 0x44, 0x26, 0x11, 0xB4'",//LD A n, LD H n, AND H
            "'0x3E, 0x44, 0x26, 0x0F, 0xB4'",
            "'0x3E, 0x44, 0x26, 0xFF, 0xB4'",
            "'0x3E, 0x44, 0x26, 0x01, 0xB4'",
            "'0x3E, 0xF4, 0x26, 0x11, 0xB4'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0xB4'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0xB4'",
            "'0x3E, 0xF4, 0x26, 0x01, 0xB4'",
            "'0x3E, 0x44, 0x2E, 0x11, 0xB5'",//LD A n, LD L n, AND L
            "'0x3E, 0x44, 0x2E, 0x0F, 0xB5'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0xB5'",
            "'0x3E, 0x44, 0x2E, 0x01, 0xB5'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0xB5'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0xB5'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0xB5'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0xB5'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0xB7'",//LD A, AND A
    })
    public void testOR(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        byte val = memory[1];
        byte val2 = memory[3];

        byte res = (byte)(val | val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(false, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }


}
