package net.saga.console.emulator.sms.sms4j.test;

import net.saga.console.emulator.sms.sms4j.test.util.ByteArrayConverter;
import net.saga.console.emulator.sms.sms4j.z80.Z80;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.converter.ConvertWith;
import org.junit.jupiter.params.provider.CsvSource;

import static net.saga.console.emulator.sms.sms4j.util.Utils.countBits;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class E07_RegBooleanLogicTest {


    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x06, 0x11, 0xA0'",//LD A n, LD B n, AND B
            "'0x3E, 0x44, 0x06, 0x0F, 0xA0'",
            "'0x3E, 0x44, 0x06, 0xFF, 0xA0'",
            "'0x3E, 0x44, 0x06, 0x01, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0x11, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0xA0'",
            "'0x3E, 0xF4, 0x06, 0x01, 0xA0'",
            "'0x3E, 0x44, 0x0E, 0x11, 0xA1'",//LD A n, LD C n, AND C
            "'0x3E, 0x44, 0x0E, 0x0F, 0xA1'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0xA1'",
            "'0x3E, 0x44, 0x0E, 0x01, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0xA1'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0xA1'",
            "'0x3E, 0x44, 0x16, 0x11, 0xA2'",//LD A n, LD D n, AND D
            "'0x3E, 0x44, 0x16, 0x0F, 0xA2'",
            "'0x3E, 0x44, 0x16, 0xFF, 0xA2'",
            "'0x3E, 0x44, 0x16, 0x01, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0x11, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0xA2'",
            "'0x3E, 0xF4, 0x16, 0x01, 0xA2'",
            "'0x3E, 0x44, 0x1E, 0x11, 0xA3'",//LD A n, LD E n, AND E
            "'0x3E, 0x44, 0x1E, 0x0F, 0xA3'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0xA3'",
            "'0x3E, 0x44, 0x1E, 0x01, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0xA3'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0xA3'",
            "'0x3E, 0x44, 0x26, 0x11, 0xA4'",//LD A n, LD H n, AND H
            "'0x3E, 0x44, 0x26, 0x0F, 0xA4'",
            "'0x3E, 0x44, 0x26, 0xFF, 0xA4'",
            "'0x3E, 0x44, 0x26, 0x01, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0x11, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0xA4'",
            "'0x3E, 0xF4, 0x26, 0x01, 0xA4'",
            "'0x3E, 0x44, 0x2E, 0x11, 0xA5'",//LD A n, LD L n, AND L
            "'0x3E, 0x44, 0x2E, 0x0F, 0xA5'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0xA5'",
            "'0x3E, 0x44, 0x2E, 0x01, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0xA5'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0xA5'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0xA7'",//LD A, AND A
    })
    public void testAnd(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        byte val = memory[1];
        byte val2 = memory[3];

        byte res = (byte)(val & val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(true, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }

    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0x11'",//LD A n, LD HL n, AND (HL)
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0x0F'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0xFF'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xA6, 0x01'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0x11'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0x0F'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0xFF'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xA6, 0x01'"
    })
    public void testAndAtHL(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(24);

        byte val = memory[1];
        byte val2 = memory[6];

        byte res = (byte)(val & val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(true, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }




    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x06, 0x11, 0xA8'",//LD A n, LD B n, XOR B
            "'0x3E, 0x44, 0x06, 0x0F, 0xA8'",
            "'0x3E, 0x44, 0x06, 0xFF, 0xA8'",
            "'0x3E, 0x44, 0x06, 0x01, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0x11, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0x0F, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0xFF, 0xA8'",
            "'0x3E, 0xF4, 0x06, 0x01, 0xA8'",
            "'0x3E, 0x44, 0x0E, 0x11, 0xA9'",//LD A n, LD C n, XOR C
            "'0x3E, 0x44, 0x0E, 0x0F, 0xA9'",
            "'0x3E, 0x44, 0x0E, 0xFF, 0xA9'",
            "'0x3E, 0x44, 0x0E, 0x01, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0x11, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0x0F, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0xFF, 0xA9'",
            "'0x3E, 0xF4, 0x0E, 0x01, 0xA9'",
            "'0x3E, 0x44, 0x16, 0x11, 0xAA'",//LD A n, LD D n, XOR D
            "'0x3E, 0x44, 0x16, 0x0F, 0xAA'",
            "'0x3E, 0x44, 0x16, 0xFF, 0xAA'",
            "'0x3E, 0x44, 0x16, 0x01, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0x11, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0x0F, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0xFF, 0xAA'",
            "'0x3E, 0xF4, 0x16, 0x01, 0xAA'",
            "'0x3E, 0x44, 0x1E, 0x11, 0xAB'",//LD A n, LD E n, XOR E
            "'0x3E, 0x44, 0x1E, 0x0F, 0xAB'",
            "'0x3E, 0x44, 0x1E, 0xFF, 0xAB'",
            "'0x3E, 0x44, 0x1E, 0x01, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0x11, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0x0F, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0xFF, 0xAB'",
            "'0x3E, 0xF4, 0x1E, 0x01, 0xAB'",
            "'0x3E, 0x44, 0x26, 0x11, 0xAC'",//LD A n, LD H n, XOR H
            "'0x3E, 0x44, 0x26, 0x0F, 0xAC'",
            "'0x3E, 0x44, 0x26, 0xFF, 0xAC'",
            "'0x3E, 0x44, 0x26, 0x01, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0x11, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0x0F, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0xFF, 0xAC'",
            "'0x3E, 0xF4, 0x26, 0x01, 0xAC'",
            "'0x3E, 0x44, 0x2E, 0x11, 0xAD'",//LD A n, LD L n, XOR L
            "'0x3E, 0x44, 0x2E, 0x0F, 0xAD'",
            "'0x3E, 0x44, 0x2E, 0xFF, 0xAD'",
            "'0x3E, 0x44, 0x2E, 0x01, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0x11, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0x0F, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0xFF, 0xAD'",
            "'0x3E, 0xF4, 0x2E, 0x01, 0xAD'",
            "'0x3E, 0xF4, 0x3E, 0xF4, 0xAF'",//LD A, AND A
    })
    public void testXor(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(18);

        byte val = memory[1];
        byte val2 = memory[3];

        byte res = (byte)(val ^ val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(true, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }

    @ParameterizedTest
    @CsvSource({
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0x11'",//LD A n, LD HL n, XOR (HL)
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0x0F'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0xFF'",
            "'0x3E, 0x44, 0x21, 0x06, 0x00, 0xAE, 0x01'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0x11'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0x0F'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0xFF'",
            "'0x3E, 0xF4, 0x21, 0x06, 0x00, 0xAE, 0x01'"
    })
    public void testXorAtHL(@ConvertWith(ByteArrayConverter.class) byte[] memory) {
        Z80 z80 = new Z80();
        z80.setMemory(memory);
        z80.cycle(24);

        byte val = memory[1];
        byte val2 = memory[6];

        byte res = (byte)(val ^ val2);

        assertEquals(res, z80.getA());
        assertEquals(res < 0, z80.getFlagS(), "Flag S contained the wrong value");
        assertEquals(z80.getA() == 0x00, z80.getFlagZ(), "Flag Z contained the wrong value");
        assertEquals(true, z80.getFlagH(), "Flag H contained the wrong value");
        boolean parity = countBits(res) % 2 == 0;
        assertEquals(parity, z80.getFlagPV(), "Flag P contained the wrong value");
        assertEquals(false, z80.getFlagC(), "Flag C contained the wrong value");
    }

}
